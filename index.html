<!DOCTYPE html>
<html>
<head>
<style>
body {
  margin: 0;
  padding: 0;
  background-color: #87CEEB;
  overflow: hidden;
  font-family: Arial, sans-serif;
}

#game {
  position: relative;
  width: 100vw;
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
}

#gameCanvas {
  border: 2px solid #333;
  background-color: #87CEEB;
}

.overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.8);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 10;
  border-radius: 10px;
  padding: 20px;
  box-sizing: border-box;
}

#titleScreen {
  /* Size will be set dynamically */
}

#instructionsScreen {
  /* Size will be set dynamically */
  background-color: rgba(0, 0, 0, 0.9);
  display: none;
  align-items: flex-start;
}

#gameOverScreen {
  /* Size will be set dynamically */
  background-color: rgba(0, 0, 0, 0.9);
  display: none;
}
</style>
</head>
<body>
<div id="game">
  <!-- Title Screen Overlay -->
  <div id="titleScreen" class="overlay">
    <h1 style="font-size: 48px; color: #FFD700; text-shadow: 2px 2px 4px #000; margin-bottom: 30px; margin-top: 0;">FlapJS</h1>
    <div>
      <button id="startButton" style="font-size: 24px; padding: 15px 30px; margin: 10px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; min-width: 150px;">Start</button>
      <button id="instructionsButton" style="font-size: 24px; padding: 15px 30px; margin: 10px; background-color: #2196F3; color: white; border: none; border-radius: 8px; cursor: pointer; min-width: 150px;">Instructions</button>
    </div>
  </div>
  
  <!-- Instructions Overlay -->
  <div id="instructionsScreen" class="overlay">
    <h2 style="color: #2196F3; margin-top: 0; margin-bottom: 15px; font-size: 24px; align-self: center;">Instructions</h2>
    <ul style="color: white; font-size: 16px; line-height: 1.6; margin: 0; padding-left: 20px;">
      <li>Press SPACE to jump/flap</li>
      <li>Press P to pause/unpause the game</li>
      <li>Press ENTER to start/restart the game</li>
    </ul>
    <div style="align-self: center; margin-top: 20px;">
      <button id="backButton" style="font-size: 18px; padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer;">Back</button>
    </div>
  </div>
  
  <!-- Game Over Overlay -->
  <div id="gameOverScreen" class="overlay">
    <h1 style="color: #FF4444; margin-top: 0; margin-bottom: 10px; font-size: 28px; text-shadow: 2px 2px 4px #000;">Game Over</h1>
    <div style="color: white; font-size: 18px; margin-bottom: 15px; text-align: center;">
      <p style="margin: 0;">Final Score</p>
      <p id="finalScore" style="font-size: 36px; margin: 5px 0; color: #FFD700; font-weight: bold;">0</p>
    </div>
    <button id="restartButton" style="font-size: 20px; padding: 12px 24px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; min-width: 120px;">Restart</button>
  </div>
</div>
</body>
<script>
(function(root, el){
  var GRAVITY_FAC = 18;
  var GRAVITY = 12 * GRAVITY_FAC;
  var JUMP_VEL = - 10 * GRAVITY_FAC;
  var MAX_UPWARD_VEL = - 7 * GRAVITY_FAC;
  var PIPE_WID = 20;
  var PIPE_PAD = PIPE_WID * 4;
  var TOP = 0;
  var BOTTOM = 200;
  var PIPE_BUF = 20;
  var RENDER_X = 60;

  // Audio context for sound effects
  var audioContext = null;
  
  function initAudio() {
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    } catch (e) {
      console.log('Web Audio API not supported');
    }
  }
  
  function playBounceSound() {
    if (!audioContext) return;
    
    var oscillator = audioContext.createOscillator();
    var gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    // Create a quick bounce sound
    oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
    oscillator.frequency.exponentialRampToValueAtTime(440, audioContext.currentTime + 0.1);
    
    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.2);
  }
  
  function playGameOverSound() {
    if (!audioContext) return;
    
    var oscillator = audioContext.createOscillator();
    var gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    // Create a descending game over sound
    oscillator.frequency.setValueAtTime(330, audioContext.currentTime);
    oscillator.frequency.exponentialRampToValueAtTime(165, audioContext.currentTime + 0.5);
    
    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.8);
  }

  // Creates the canvas
  function setupCanvas(parent) {
    var canvas = document.createElement('canvas');
    canvas.id = 'gameCanvas';
    canvas.style.cursor = 'none';
    
    // Calculate size maintaining 5:2 aspect ratio (500:200)
    function resizeCanvas() {
      var windowWidth = window.innerWidth;
      var windowHeight = window.innerHeight;
      var aspectRatio = 500 / 200; // 2.5
      
      var canvasWidth, canvasHeight;
      
      if (windowWidth / windowHeight > aspectRatio) {
        // Window is wider than our aspect ratio
        canvasHeight = windowHeight * 0.9; // 90% of window height
        canvasWidth = canvasHeight * aspectRatio;
      } else {
        // Window is taller than our aspect ratio
        canvasWidth = windowWidth * 0.9; // 90% of window width
        canvasHeight = canvasWidth / aspectRatio;
      }
      
      canvas.width = 500; // Keep internal resolution
      canvas.height = 200;
      canvas.style.width = canvasWidth + 'px';
      canvas.style.height = canvasHeight + 'px';
      
      // Update overlay sizes to match canvas
      updateOverlaySizes(canvasWidth, canvasHeight);
    }
    
    resizeCanvas();
    parent.appendChild(canvas);
    
    // Add resize listener
    window.addEventListener('resize', resizeCanvas);
    
    return canvas;
  }
  
  function updateOverlaySizes(canvasWidth, canvasHeight) {
    var titleScreen = document.getElementById('titleScreen');
    var instructionsScreen = document.getElementById('instructionsScreen');
    var gameOverScreen = document.getElementById('gameOverScreen');
    
    // Scale overlays to match canvas size
    titleScreen.style.width = canvasWidth + 'px';
    titleScreen.style.height = canvasHeight + 'px';
    
    instructionsScreen.style.width = canvasWidth + 'px';
    instructionsScreen.style.height = canvasHeight + 'px';
    
    gameOverScreen.style.width = canvasWidth + 'px';
    gameOverScreen.style.height = canvasHeight + 'px';
    
    // Scale font sizes based on canvas size
    var scaleFactor = Math.min(canvasWidth / 500, canvasHeight / 200);
    
    // Scale title screen
    var title = titleScreen.querySelector('h1');
    title.style.fontSize = (48 * scaleFactor) + 'px';
    
    var startButton = document.getElementById('startButton');
    var instructionsButton = document.getElementById('instructionsButton');
    startButton.style.fontSize = (24 * scaleFactor) + 'px';
    startButton.style.padding = (15 * scaleFactor) + 'px ' + (30 * scaleFactor) + 'px';
    instructionsButton.style.fontSize = (24 * scaleFactor) + 'px';
    instructionsButton.style.padding = (15 * scaleFactor) + 'px ' + (30 * scaleFactor) + 'px';
    
    // Scale instructions screen
    var instructionsTitle = instructionsScreen.querySelector('h2');
    var instructionsList = instructionsScreen.querySelector('ul');
    var backButton = document.getElementById('backButton');
    
    instructionsTitle.style.fontSize = (24 * scaleFactor) + 'px';
    instructionsList.style.fontSize = (16 * scaleFactor) + 'px';
    backButton.style.fontSize = (18 * scaleFactor) + 'px';
    backButton.style.padding = (10 * scaleFactor) + 'px ' + (20 * scaleFactor) + 'px';
    
    // Scale game over screen
    var gameOverTitle = gameOverScreen.querySelector('h1');
    var finalScoreText = gameOverScreen.querySelector('div');
    var finalScoreNumber = document.getElementById('finalScore');
    var restartButton = document.getElementById('restartButton');
    
    gameOverTitle.style.fontSize = (28 * scaleFactor) + 'px';
    finalScoreText.style.fontSize = (18 * scaleFactor) + 'px';
    finalScoreNumber.style.fontSize = (36 * scaleFactor) + 'px';
    restartButton.style.fontSize = (20 * scaleFactor) + 'px';
    restartButton.style.padding = (12 * scaleFactor) + 'px ' + (24 * scaleFactor) + 'px';
  }
  // generates a new pipe at a point after the last active pipe
  function newPipes(game) {
    var holeSize = {
      width: PIPE_WID,
      height: game.hero.size.height * 6
    };

    var minHole = holeSize.height;
    var maxHole = BOTTOM - holeSize.height;
    var hole;
    
    // Prevent same gap position twice in a row
    do {
      hole = Math.floor(Math.random() * (maxHole - minHole)) + minHole;
    } while (game.lastHole && Math.abs(hole - game.lastHole) < holeSize.height * 0.5);
    
    game.lastHole = hole;

    var lastPipe = game.pipes[game.pipes.length - 1];
    var x = lastPipe ? lastPipe.pos.x + PIPE_PAD : 150;
    var h2 = holeSize.height/2;
    var holePts = [hole - h2, hole + h2];

    var p1 = {
      pos: {
        x: x,
        y: TOP
      },
      size: {
        width: PIPE_WID,
        height: (hole - h2)
      },
      passed: false
    };
    var p2 = {
      pos: {
        x: x,
        y: hole + h2
      },
      size: {
        width: PIPE_WID,
        height: (BOTTOM - (hole + h2))
      },
      passed: false
    };

    return [p1, p2];
  }

  function newGame() {
    var game = {
      hero: {
        pos: {
          x: 20, y: 20
        },
        size: {
          width: 15, height: 10
        },
        vel: {
          x: 50, y: 0
        }
      },
      pipes: [ ],
      score: 0,
      lastHole: null,
      state: 'title' // 'title', 'instructions', 'playing', 'gameover'
    };


    return game;
  }

  function pt(x,y) {
    return {x:x, y:y};
  }
  function addToPt(a, b) {
    a.x += b.x;
    a.y += b.y;
    return a;
  }
  function addPt(a, b) {
    return {
      x: a.x + b.x,
      y: a.y + b.y
    };
  }

  function heroIsOutOfBounds(hero) {
    return hero.pos.y > BOTTOM;
  }

  function isGameOver(game) {
    if(heroIsOutOfBounds(game.hero)) return true;

    for(var i = 0; i<game.pipes.length; i ++ ) {
      if(collides(game.hero, game.pipes[i])) return true;
    }
    return false;
  }

  // tick the game by delta seconds
  function tick(game, delta) {
    if(game.state !== 'playing') {
      return;
    }
    
    if(game.pause || game.isGameOver) {
      return;
    } else if(isGameOver(game)) {
      game.isGameOver = true;
      playGameOverSound();
      enableStartButton(game);
      return;
    }

    var dAcel = {
      x: 0,
      y: GRAVITY * delta
    };
    var dPt = {
      x: game.hero.vel.x * delta,
      y: game.hero.vel.y * delta + 0.5 * GRAVITY * delta * delta
    };
    addToPt(game.hero.pos, dPt);
    addToPt(game.hero.vel, dAcel);
    handlePipes(game);
  }

  function cleanupPipes(game) {
    while(game.pipes.length > 0 && 
      game.pipes[0].pos.x + game.pipes[0].size.width + RENDER_X < 
        game.hero.pos.x - game.hero.size.width) {
      game.pipes.shift();
    }
  }
  function addPipes(game) {
    while(game.pipes.length < PIPE_BUF) {
      game.pipes.push.apply(game.pipes, newPipes(game));
    }
  }
  function checkScore(game) {
    var heroRight = game.hero.pos.x + game.hero.size.width;
    
    for (var i = 0; i < game.pipes.length; i += 2) {
      var topPipe = game.pipes[i];
      var bottomPipe = game.pipes[i + 1];
      
      if (topPipe && !topPipe.passed && heroRight > topPipe.pos.x + topPipe.size.width) {
        topPipe.passed = true;
        if (bottomPipe) bottomPipe.passed = true;
        game.score++;
      }
    }
  }

  function handlePipes(game) {
    cleanupPipes(game);
    addPipes(game);
    checkScore(game);
  }

  function between(b, a, c) {
    return (a < b && b <= c) || 
      (a >= b && b > c);
  }

  function within(pt, b) {
    if(between(pt.x, b.pos.x, b.pos.x + b.size.width) &&
      between(pt.y, b.pos.y, b.pos.y + b.size.height)) return true;

    return false;
  }

  function farPt(ent) {
    return {
      x: ent.pos.x + ent.size.width,
      y: ent.pos.y + ent.size.height
    };
  }

  function p(ent) {
    return "[size=" + ent.size.width + "," + ent.size.height + 
      " pos=" + ent.pos.x + "," + ent.pos.y +  "]";
  }

  function allPts(ent) {
    return [pt(0, 0), pt(ent.size.width, 0),
      pt(0, ent.size.height), pt(ent.size.width, ent.size.height)].
      map(function(d) {
        return addPt(ent.pos, d);
      });
  }

  function anyPtsWithin(a, b) {
    var allPtsA = allPts(a);
    for(var i = 0; i < allPtsA.length; i ++ ) {
      if(within(allPtsA[i], b)) return true;
    }
    return false;
  }

  function collides(a, b) {
    if(anyPtsWithin(a, b)) return true;
    if(anyPtsWithin(b, a)) return true;

    return false;
  }

  function drawHero(cxt, hero) {
    var x = RENDER_X;
    var y = hero.pos.y;
    var w = hero.size.width;
    var h = hero.size.height;
    
    // Calculate rotation smoothly based on velocity
    var maxUpwardTilt = -1.0; // Maximum upward tilt (radians)
    var maxDownwardTilt = 1.2; // Maximum downward tilt (radians)
    var maxVelocity = 250; // Velocity at which max tilt is reached
    
    var rotation = Math.max(maxUpwardTilt, Math.min(maxDownwardTilt, hero.vel.y / maxVelocity * maxDownwardTilt));
    
    // Save context and apply rotation
    cxt.save();
    cxt.translate(x + w/2, y + h/2);
    cxt.rotate(rotation);
    cxt.translate(-(w/2), -(h/2));
    
    // Draw bird body (oval)
    cxt.fillStyle = '#FFD700'; // Golden yellow
    cxt.beginPath();
    cxt.ellipse(w/2, h/2, w/2.5, h/2.5, 0, 0, 2 * Math.PI);
    cxt.fill();
    
    // Draw bird head (smaller circle)
    cxt.fillStyle = '#FFD700';
    cxt.beginPath();
    cxt.ellipse(w*0.8, h*0.3, w/4, h/4, 0, 0, 2 * Math.PI);
    cxt.fill();
    
    // Draw beak (triangle)
    cxt.fillStyle = '#FF8C00'; // Orange
    cxt.beginPath();
    cxt.moveTo(w*0.95, h*0.3);
    cxt.lineTo(w*1.1, h*0.25);
    cxt.lineTo(w*0.95, h*0.4);
    cxt.closePath();
    cxt.fill();
    
    // Draw eye (small black circle)
    cxt.fillStyle = 'black';
    cxt.beginPath();
    cxt.ellipse(w*0.85, h*0.25, w/12, h/12, 0, 0, 2 * Math.PI);
    cxt.fill();
    
    // Draw wing (ellipse)
    cxt.fillStyle = '#FFA500'; // Orange
    cxt.beginPath();
    cxt.ellipse(w*0.4, h*0.6, w/3, h/6, -0.3, 0, 2 * Math.PI);
    cxt.fill();
    
    // Restore context
    cxt.restore();
  }
  function drawPipe(cxt, pipe, adjX) {
    var x = pipe.pos.x - (adjX - RENDER_X);
    var y = pipe.pos.y;
    var w = pipe.size.width;
    var h = pipe.size.height;
    
    // Main pipe body (darker green)
    cxt.fillStyle = '#228B22'; // Forest green
    cxt.fillRect(x + 2, y, w - 4, h);
    
    // Pipe cap (wider section at the end)
    var capHeight = Math.min(8, h * 0.2);
    var capWidth = w + 4;
    var capX = x - 2;
    
    // Determine if this is a top pipe or bottom pipe based on position
    var isTopPipe = y === 0;
    var capY = isTopPipe ? y + h - capHeight : y;
    
    // Draw pipe cap
    cxt.fillStyle = '#32CD32'; // Lime green
    cxt.fillRect(capX, capY, capWidth, capHeight);
    
    // Add highlight on the left side of pipe
    cxt.fillStyle = '#90EE90'; // Light green
    cxt.fillRect(x + 2, y, 2, h);
    
    // Add shadow on the right side of pipe
    cxt.fillStyle = '#006400'; // Dark green
    cxt.fillRect(x + w - 4, y, 2, h);
    
    // Add highlight on pipe cap
    cxt.fillStyle = '#98FB98'; // Pale green
    cxt.fillRect(capX, capY, 2, capHeight);
  }

  function render(game, canvas) {
    var cxt = canvas.getContext('2d');

    cxt.clearRect(0, 0, canvas.width, canvas.height);
    
    if (game.state === 'playing') {
      drawHero(cxt, game.hero);

      game.pipes.forEach(function(pipe) {
        drawPipe(cxt, pipe, game.hero.pos.x);
      });

      // Draw score
      cxt.fillStyle = 'black';
      cxt.font = '24px Arial';
      cxt.fillText('Score: ' + game.score, 10, 30);
    }
  }

  function setupEventHandlers(game) {
    document.addEventListener('keydown', function(evt) {
      if (game.state === 'instructions' && evt.keyCode === 27) { // ESC key
        showTitleScreen(game);
      } else if (game.state === 'playing') {
        if (evt.keyCode == 80) { // P key
          game.pause = ! game.pause;
        } else if(evt.keyCode == 32 && !game.isGameOver) { // space
          game.hero.vel.y += JUMP_VEL;
          if (game.hero.vel.y < MAX_UPWARD_VEL) {
            game.hero.vel.y = MAX_UPWARD_VEL;
          }
          playBounceSound();
        }
      }
    });
  }
  
  function genRequestAnimFunction(root, game, canvas, callback) {
    var lastTimestamp = 0;
    var requestAnim = function (timestamp) {
      var elapsed = timestamp - (lastTimestamp || timestamp);
      elapsed = elapsed / 1000.0;
      tick(game, elapsed);
      render(game, canvas);
      lastTimestamp = timestamp;

      callback(requestAnim);
    };
    return requestAnim;
  }


  function startGame(game) {
    game.state = 'playing';
    game.isGameOver = false;
    game.pause = false;
    game.score = 0;
    game.pipes = [];
    game.hero.pos = {x: 20, y: 20};
    game.hero.vel = {x: 50, y: 0};
    game.lastHole = null;
    
    // Hide all overlays
    document.getElementById('titleScreen').style.display = 'none';
    document.getElementById('instructionsScreen').style.display = 'none';
    document.getElementById('gameOverScreen').style.display = 'none';
    
    initAudio();
  }
  
  function showInstructions(game) {
    game.state = 'instructions';
    document.getElementById('titleScreen').style.display = 'none';
    document.getElementById('instructionsScreen').style.display = 'flex';
    document.getElementById('gameOverScreen').style.display = 'none';
  }
  
  function showTitleScreen(game) {
    game.state = 'title';
    document.getElementById('titleScreen').style.display = 'flex';
    document.getElementById('instructionsScreen').style.display = 'none';
    document.getElementById('gameOverScreen').style.display = 'none';
  }
  
  function showGameOver(game) {
    game.state = 'gameover';
    
    // Update final score display
    document.getElementById('finalScore').textContent = game.score;
    
    // Show game over screen
    document.getElementById('titleScreen').style.display = 'none';
    document.getElementById('instructionsScreen').style.display = 'none';
    document.getElementById('gameOverScreen').style.display = 'flex';
  }

  function enableStartButton(game) {
    showGameOver(game);
  }

  var canvas = setupCanvas(el);
  var game = newGame();
  
  setupEventHandlers(game);
  
  var startButton = document.getElementById('startButton');
  var instructionsButton = document.getElementById('instructionsButton');
  var backButton = document.getElementById('backButton');
  var restartButton = document.getElementById('restartButton');
  
  startButton.addEventListener('click', function() {
    if (game.state === 'title') {
      startGame(game);
    } else if (game.state === 'instructions') {
      showTitleScreen(game);
    }
  });
  
  instructionsButton.addEventListener('click', function() {
    showInstructions(game);
  });
  
  backButton.addEventListener('click', function() {
    showTitleScreen(game);
  });
  
  restartButton.addEventListener('click', function() {
    startGame(game);
  });
  
  // Global Enter key listener for starting/restarting game
  document.addEventListener('keydown', function(evt) {
    if (evt.keyCode == 13) { // Enter key
      if (game.state === 'title' || game.state === 'gameover') {
        startGame(game);
      } else if (game.state === 'instructions') {
        showTitleScreen(game);
      }
    }
  });
  
  // Start the animation loop
  if(root.requestAnimationFrame) {
    var fun = genRequestAnimFunction(root, game, canvas, function(funRequest) {
      root.requestAnimationFrame(funRequest);
    });
    root.requestAnimationFrame(fun);
  }

})(window, document.getElementById('game'));
</script>
</html>

